\section{Introduction}
Shipping microcontrollers to consumers exposes them to a plethora of attacks on the actual hardware.
One class of such attacks focuses on analyzing unintended information leakage from the microcontroller, the so-called \sidechannel{} attacks.
If the processed data influences some observable metric, an attacker can measure that metric and then reason about the values of said data.
The microcontroller can thus leak information, which is especially devastating if the information in question is a cryptographic secret.

One such metric that can leak information is the power consumption of the microcontroller.
Setting a binary value in registers, main memory etc. consumes power directly related to the number of bits to be set to 1.
By measuring the power consumption traces during execution an attacker can gain information about the \hammingw{} (number of 1s) of the processed data.
If she also knows which cryptographic operation is being performed (a reasonable assumption under Kerckhoff's principle), and can control the input, she can infer the value of the cryptographic secret via statistical anlysis of the power traces.
%% As microcontrollers rarely utilize instruction level parallelism these power traces have relatively little noise, making them especially susceptible to such an attack.
A comparatively low clock rate and power traces that are low in noise due to the lack of parallelism make embedded platforms especially susceptible to such an attack.

As performing cryptographic operations is \emph{exactly} the use case of many embedded devices (SmartCards etc.) defensese against \poweranalysis{} have been amply explored.
However, the most commonly used defenses are either algorithm specific, like masking, or require significant changes to the hardware, like \dual{}.
\dual{} is applicable to any code as it computes the inverse of every intermediate value, along with the values itself, to ensure the power consumption is always constant.
\\
\\
In my thesis I explore the possibilities of implementing \dual{} in software.
I simulate the computation of the inverse by keeping the inverse of an 8bit value, along with the actual 8bit value, in the same 32bit register.
By doing so I drastically reduce the variance of \hammingw{}s during execution, and thus make the program more robust to power analysis.
While this requires making significant changes to the code, all of these changes are made automatically in the compiler, and the hardening is thus applicable to \emph{any} code that is written for an 8bit architecture.

By providing a proof of concept with evaluation I hope to open a new perspective on this problem, providing a solution for cases where execution time is not of the essence, but circuit space is limited.
For these cases my thesis can provide a way of hardening the execution without any security knowledge of the programmer at all.
