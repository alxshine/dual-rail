\section{Balancing Pass}
\label{pass}
The idea behind the balancing pass is very simple.
\begin{enumerate}
\item Change the type of all 8bit integers (\lli8) to 32bit integers (\lli32)
\item Use balanced arithmetic operations instead of regular operators
\item Fix comparison directions
\item Fix type issues that arise in the instructions that have not been replaced
\end{enumerate}

In the following subsections I will describe the changes that my pass makes, ordered by the lifecycle of a variable in \ir{}.
As I decided to focus on stack memory only, the operations and lifecycle are specific to local variables.
%TODO: talk about the llvm c++ api

\subsection{Cloning Functions}
The first types used in a function are its return type and the types of its function parameters.
As these types cannot be changed for an existing function in \llvm{} I need to clone the functions with updated types.

Cloning functions is done in two parts.
First the prototype for the new function is created.
During creation the pass goes through all parameter and changes their types from \lli8 to \lli32.
The same is done for the return type.
This gives me a skeleton for the balanced function, which is then inserted into the module, making it accessible in the future.

The content of the original function is then copied using a helper in the \llvm{} API called \emph{CloneFunctionInto}.
Without any additional parameters, the copied instructions will still reference function parameters of the original function, which are invalid in the new function.
To avoid this I use a so-called \emph{Value Mapper} to replace the old parameters with the new ones everywhere they are referenced.
This change alone would cause type mismatches and generates code that does not compile, but the other steps of my pass fix these problems.

\subsection{Balancing Allocations}
In order to declare and use local variables in \ir{} the memory for them first has to be allocated using the \emph{alloca} instruction.
Even function parameters are not used directly but first copied into memory explicitly allocated for this function.
Note that even though the naming is similare to C's \emph{malloc} call, the memory for \emph{alloca} is on the stack in this case.

The \emph{alloca} instruction takes the type to be allocated as parameter, and returns a pointer to that type.
This means that for balancing all the pass has to do is replace the \emph{alloca} for \lli8 with one for \lli32.
Allocations for local arrays work the same way, the pass just needs to extract the number of elements from the old allocation.

\subsection{Balancing Stores}
It can happen that the target code tries to store a balanced variable (\lli32) into an unbalanced pointer (\lli8).
In this case the pass unbalances the variable in a temporary before storing it.

While this does cause information leakage and a reduction in robustness, such a case can be avoided fairly easily.
As only global memory is unbalanced, this does not happen when the program stores all values on the stack.

\subsection{Balancing Loads}
Balancing loads is a mirror case of balancing stores.
When loading from an unbalanced pointer into a balanced variable, the pass first loads into an unbalanced temporary and then balances the value before storing it in the local variable.

\subsection{Balancing ZExts}
\emph{ZExt} stands for zero extend, and it is an instruction used to promote integer types to larger bit sizes.
While my pass is meant to balance code utilizes \emph{only 8bit integers}, I needed to balance \emph{ZExts} for compatibilty reasons during development and have left the balancing procedure in the code.

When zero extending from 8 to 32 bit, the pass replaces the instruction with a call to my balance function.
When extending from 32 to 64 bit it unbalances the value first and then zero extends to the target type.

\subsection{Balancing Binary Operations}
I implemented the balanced operations described in \Cref{operations} in C, each as an individual function.
In order to balance binary operations they need to be replaced by calls to these new functions.
As all binary operations are represented by the same instruction in the \llvm{} API, the pass needs to examine the \emph{opcode} of the instruction.
Based on that it decides which function call to generate.

For most operations the balanced operation is a direct implementation of the respective steps in \Cref{arithmetic}.
Multiplication, division, and remainder however are implemented by repeated addition/subtraction.
As an example, \Cref{lst:sdiv} shows the balanced function for the \texttt{sdiv} operation in \ir{}.

\begin{lstlisting}[language=C, caption=Balanced sdiv, label=lst:sdiv]
int balanced_sdiv(int lhs, int rhs) {
  uint32_t ret = 0x00ff0000;

  uint8_t negative = 0;
  if(rhs & 0x00000080){
    negative = 1;
    rhs = balanced_negative(rhs);
  }


  while (lhs <= rhs) { //~x <= ~y iff x >= y
    lhs = balanced_sub(lhs, rhs);
    ret = balanced_add(ret, 0x00fe0001);
  }

  if(negative)
    return balanced_negative(ret);
  else
    return ret;
}
\end{lstlisting}

The semantics, especially the handling of negative values are made to be consistent with the semantics of \llvm{}.

\subsection{Balancing Pointer Arithmetic}
Balanced values cannot be used for array indexing directly.
Therefore, whenever a balanced variable is used as index for an array access it is unbalanced before use.
All array accesses use the \emph{getelementptr} instruction in \ir{}, so this is easy to catch.
This does not handle manual arithmetic operations with pointers, but that is by design.

\subsection{Balancing Compares}
In my main balancing scheme (\Cref{fig:scheme1}) the inverse occupies more significant bits than the value itself.
This changes the direction of comparison operations, meaning $<$ becomes $>$, $>=$ becomes $<=$ etc.
For $==$ nothing changes and the other comparisons are simply replaced.
