
%% \subsection{\llvm{}}
%% \label{llvm}
%% The \llvm{} compiler infrastructure project\cite{lattner2010llvm} contains a number of subprojects, but for my thesis the \lc{} libraries are the only part that is relevant.
%% They contain a source and target independent compiler, which can be extended using multiple front- and backends.
%% This makes \llvm{} the extremely versatile, and allows for easy extension.
%% \Cref{fig:llvm} sketches the general architecture of \llvm{}.

%% \begin{figure}[h]
%%   \centering
%%   \begin{tikzpicture}
%%     \node[draw, minimum width=1.3cm, minimum height=0.6cm] at (-2.5,1.5) (C) {C};
%%     \node[draw, minimum width=1.3cm, minimum height=0.6cm] at (-2.5,0.5) (C++) {C++};
%%     \node[draw, minimum width=1.3cm, minimum height=0.6cm] at (-2.5, -0.5) (Haskell) {Haskell};
%%     \node[draw, minimum width=1.3cm, minimum height=0.6cm] at (-2.5, -1.5) (otherl) {...};
%%     \node[draw] at (-0.75, 0) (irl) {IR};
    
%%     \node[draw, label=Optimization Passes, minimum width=4cm, minimum height=1.3cm] at (2,0) (optimization) {};
%%     \node[draw, minimum size=0.5cm] at (0.6,0) {};
%%     \node[draw, minimum size=0.5cm] at (1.2,0) {};
%%     \node[draw, minimum size=0.5cm] at (1.8,0) {};
%%     \node[draw, minimum size=0.5cm] at (2.4,0) {};
%%     \node at (3.0, 0) {...};

%%     \node[draw] at (4.75, 0) (irr) {IR};
%%     \node[draw, minimum width=1.3cm, minimum height=0.6cm] at (6.5,1) (x86) {x86};
%%     \node[draw, minimum width=1.3cm, minimum height=0.6cm] at (6.5,0) (arm) {ARM};
%%     \node[draw, minimum width=1.3cm, minimum height=0.6cm] at (6.5,-1) (otherr) {...};

%%     \draw[->] (C) -- (irl);
%%     \draw[->] (C++) -- (irl);
%%     \draw[->] (Haskell) -- (irl);
%%     \draw[->] (otherl) -- (irl);

%%     \draw[->] (irl) -- (optimization);
%%     \draw[->] (optimization) -- (irr);

%%     \draw[->] (irr) -- (x86);
%%     \draw[->] (irr) -- (arm);
%%     \draw[->] (irr) -- (otherr);
%%   \end{tikzpicture}
%%   \caption{The general architecture of the \llvm{} compiler}
%%   \label{fig:llvm}
%% \end{figure}

%% At the heart of \lc{} is a number of optimization passes.
%% These passes take \ir{} as input and provide \ir{} as output, making it easy to insert new passes and reorder existing ones.
%% My plugin is implemented as such a pass, and as such can simply be called during compilation.

%% %% \subsection{Static Single Assignment Form}
%% %% \label{ssa}
%% %% In order to understand \ir{} we first need to understand the basics of static single assignment form (SSA).
%% %% The basic premise of SSA is simple: every value assignment is stored in a new variable.
%% %% Analysis of variable usage, register requirements (liveness), dead code, etc. is thus greatly simplified.

%% %% Some notations for SSA annotate the variable names with indices to make them unique.
%% %% \ir{} completely forgoes the names of variables, instead using just numbers, preceded by a \%.

%% %% \subsection{\llvm{} Intermediate Representation}
%% %% \label{ir}
%% %% \ir{} is best described as typed assembly written in SSA.
%% %% The instructions provided by \ir{} are very similar to RISC assembly.
%% %% \ir{} uses SSA variables, which have types associated with them, based on their assignment.
%% %% This allows typechecking during every step of the compiler, especially between optimization passes.

%% %% \ir{} also explicitly defines functions with a prototype, complete with typed arguments and return type.

%% \subsubsection{\llvm{} C++ API}
%% \label{api}
%% \llvm{} provides a C++ API for extending the compiler.
%% This API exposes all functions that \llvm{} itself uses, giving the programmer full access to all capabilities.
%% For my thesis I mainly used the code inspection and generation utilities, going through the generated \ir{} code and balancing it, in an optimization pass.

%% The pass can then be compiled into a library (see \Cref{buildpass}), which is loaded as an \llvm{} plugin during the compilation process.

%% \subsection{\qemu{}}
%% \label{qemu}
%% \qemu{} is a generic and open source machine emulator and virtualizer.\cite{bellard2005qemu}
%% While it can be used as a full fledged virtualization environment and sandbox, it can also emulate different processor architectures for programs without first emulating an OS.
%% I use this ability for the evaluation of my thesis, executing the compiled program and storing the \hammingw{}s during execution.


%% \subsubsection{Memory Layout of \qemu{} Kernels}
%% \label{memory}
%% Even with bare-metal emulation, \qemu{} still takes its input as a kernel.
%% Due to this, it starts execution at address \hex{1000}, as everything before that address is usually reserved for interrupt handling.
%% This requires some additional setup in my build process (see \Cref{buildtest}).

%% \subsection{AES and RC4}
%% AES\cite{daemen2013design} and RC4\cite{rc4} are the two evaluation programs for my compiler pass.
%% I chose RC4 because it is very simple and used to be the industry standard, and AES because it is the current industry standard for symmetric encryption.
%% Both fit the main use cases of embedded devices, and are thus reasonable choices for evaluating the robustness of my thesis project.
