\section{Instrumenting \qemu{} for Evaluation}
\label{evaluation}
\qemu{} does not simply interpret the guest code in a simulated processor.
Instead it translates the machine code for the guest platform into machine code for the host platform, and places that ``patched'' machine code in memory.
A second executor thread then runs that code as it becomes available.

This translation backend is called the Tiny Code Generator (TCG), which not only performs the translation but also some optimizations.
Instrumenting \qemu{} for analysis is hard due to the fact that the TCG works through multiple layers of indirection, utilizing both helper functions and preprocessor macros, some of which are defined in different files depending on the host architecture (the specific definition file is chosen while building \qemu{}).
As documentation is also sparse, finding a good place to put my evaluation code required a lot of time and effort.

Even after understanding all the parts of \qemu{}'s way of emulating code, I was left with a problem.
The executor thread does not know what code it is executing, it only has a pointer (the simulated program counter) to the next instruction or the next basic block.
The TCG on the other hand knows which operations are being executed, but it does not know the values of the operands.
It also has no way of accessing these values as they might not even be computed yet.
So short of either parsing the memory at the simulated program counter or writing a symbolic execution engine (essentially replacing \qemu{}) I did not know how to proceed.

Luckily, \qemu{} offers emulation via the TCG Interpreter (TCI).
The TCI does exactly what I was looking for in the first place, i.e. emulating the guest processor in C.
I then placed my instrumentation code in the operator functions of the TCI, generating a histogram of \hammingw{}s during the execution.
