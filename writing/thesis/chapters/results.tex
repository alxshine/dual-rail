\chapter{Results}
\label{results}
For the evaluation both the balanced and the unbalanced version were compiled using my Clang and GNU cross compiler toolchain.
Both versions were compiled using the \texttt{-O0} option, to avoid the influence of any optimizations.
\Cref{tbl:properties} shows a summary of the properties of both versions.
\Cref{fig:rc4,fig:aes} contain histograms of \hammingw{}s during execution of the balanced and unbalanced code.
A more detailed discussion of the results follows.
  
\begin{table}[h]
  \begin{tabular}{|l|l|l|l|l|}
    \hline
    & \multicolumn{2}{c|}{RC4}  & \multicolumn{2}{c|}{AES} \\
    \cline{2-5}
    & unbalanced & balanced & unbalanced & balanced \\
    \cline{2-5}
    Balancedness      & 0.236 & 0.455 & 0.362  & 0.584 \\
    No. of Operations & 77349 & 401287 & 83549 & 2396186 \\
    Relative Increase & 1 & 5.19 & 1 & 26.68 \\
    Code Size            & 3.5 KB & 3.1 KB & 5.8 KB & 14 KB \\
    \hline
  \end{tabular}
  \caption{Properties of balanced and unbalanced test code}
  \label{tbl:properties}
\end{table}

\begin{figure}[hp]
  \centering
  \begin{subfigure}[b]{0.49\textwidth}
    \input{tikz/rc4-unbalanced.tex}
    \caption{Unbalanced RC4}
  \end{subfigure}
  \begin{subfigure}[b]{0.49\textwidth}
    \input{tikz/rc4-balanced.tex}
    \caption{Balanced RC4}
  \end{subfigure}

  \begin{subfigure}[b]{\textwidth}
    \input{tikz/rc4-comparison.tex}
    \caption{Scaled Hamming weight histograms for RC4}
  \end{subfigure}
  \caption{Hamming weight histograms for balanced and unbalanced RC4}
  \label{fig:rc4}
\end{figure}

\begin{figure}[hp]
  \centering
  \begin{subfigure}[b]{0.49\textwidth}
    \input{tikz/aes-unbalanced.tex}
    \caption{Unbalanced AES}
  \end{subfigure}
  \begin{subfigure}[b]{0.49\textwidth}
    \input{tikz/aes-balanced.tex}
    \caption{Balanced AES}
    \label{fig:aes-balanced}
  \end{subfigure}

  \begin{subfigure}[b]{\textwidth}
    \input{tikz/aes-comparison.tex}
    \caption{Scaled Hamming weight histograms for AES}
    \label{fig:aes-comp}
  \end{subfigure}
  \caption{Hamming weight histograms for balanced and unbalanced AES}
  \label{fig:aes}
\end{figure}

\section{Robustness}
As visible in both \Cref{fig:rc4} and \Cref{fig:aes}, the balanced version has a much narrower distribution of \hammingw{}s.
Although my balancing does not reach the perfect outcome of identical \hammingw{}s for all operations, it shows a significant move towards it.
Perfect balancing cannot be reached with current ALUs, as their design forces imbalances in intermediate values.
For this reason the balancedness in \Cref{tbl:properties} is the ratio of \hammingw{}s in the range between 7 and 9, and not only the ratio of \hammingw{}s of 8.

The balancedness metric in \Cref{tbl:properties} is a very simplistic metric, however, and the histograms in \Cref{fig:rc4,fig:aes} paint a much clearer picture of the effectiveness of my balanced arithmetic.
The balancing works especially well for AES, as shown in \Cref{fig:aes-balanced}.
A large number of values is perfectly balanced, as signified by the large value at 8.
This is due to the large number of table lookups.
In the beginning of my code the lookup tables are copied onto the stack, which causes them to be balanced.
Another cause is the frequent usage of XOR operations, which are perfectly balanced in my arithmetic.
The additional spike around 9 is likely caused by the large number of loops in AES, causing a many increment operations and therefore additions.
However, I am not entirely certain this is the only reason, as RC4, which has a similarly high ratio of increments, does not exhibit the same behaviour.

For RC4 the balancing does not work as well.
The largest spike in \hammingw{}s is at 7 here, and the variance is higher.
This value is only an intermediate \hammingw{} for balanced subtraction, which does not occur in RC4.
Due to this I assume this is caused by array accesses, which require the value to be unbalanced before it can be used as index.
Another possibility is that this is some artifact not directly linked to my arithmetic.
The number of values with \hammingw{} 7 is roughly the same as in AES, which supports this theory.

For both AES and RC4 the histograms indicate increased robustness, and the reduced variance in histograms should reduce the amount of information retrievable by an attacker.

\section{Performance}
Unfortunately the performance impact of my balancing pass is rather large.
As shown in \Cref{tbl:properties} the number of operations increases by a factor of 5.19 for RC4, and by a factor of 26.68 for AES.
A possible reason for this discrepancy is the larger number of array accesses in AES, which all require unbalancing.

Code size does not increase as drastically.
For RC4, the balanced code actually requires \emph{less} memory than the unbalanced version.
This might be caused by a simple dead code removal routine I added to reduce the lines of code in the \ir{} files during debugging.
The code size for balanced AES should also be fine for most embedded platforms, as that already includes all lookup tables.
The moderate increase in code size is caused by the balanced operators being implemented as functions, and not being inlined during compilation.
Adding inlining for the operators would allow for an additional memory-performance tradeoff, if desired.
Calling the operator functions causes overhead (storing and restoring of registers, etc.), which is likely the main cause of the increased memory size.
Another probable cause is the unbalancing instructions before array indexing.
These are also implemented as functions, again causing overhead.

The code was not optimized (compiled with \texttt{-O0}), so there was no loop unrolling.
This would cause an additional increase in code size for the case of inlined operators.

While the performance impact is (prohibitively) large, please note that performance was not a focus for my thesis.
